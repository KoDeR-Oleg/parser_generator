\chapter{Реализации}


\Section{MarkupTypeRegistry}

Singleton определяющий поддерживаемые типы деревьев. На данный момент имеется поддержка типов <<HTMLTree>> и <<JSONTree>>, задающих деревья на HTML и JSON структурах соответственно. Содержит единственный метод:
\\

\begin{lstlisting}
def get_tree(self, markup_type, raw_page)
\end{lstlisting}
Метод возвращает дерево типа с названием $markup\_type$, построенного по строке $raw\_page$.
\\

\Section{HTMLTree}

Дерево структуры HTML, представляет из себя обёртку над деревом $lxml.html$ с добавлением реализации методов интерфейса $Tree$.
\\

\begin{lstlisting}
def __init__(self, **kwargs)
\end{lstlisting}
Может принимать $raw\_page$ или $html\_tree$. В первом случае с помощью методов библиотеки $lxml.html$ из HTML строки строится дерево, во втором -- сохраняется указатель на переданное дерево типа $lxml.html$. Поля $tag$ и $classes$ также берутся из соответствующих полей типа $lxml.html$.
\\

\begin{lstlisting}
def cssselect(self, attribute)
\end{lstlisting}
Используется одноимённый метод библиотеки $lxml.html$.
\\

\begin{lstlisting}
def get_iter(self)
\end{lstlisting}
Возвращает экземпляр класса $TagIterator$, представляющего собой обёртку над методом $iter$ класса $lxml.html$.
\\

\begin{lstlisting}
def get_elements(self, html_path)
\end{lstlisting}
Используется метод $xpath$ класса $lxml.html$, все элементы результата которого оборачиваются в $HTMLTree$.
\\

\begin{lstlisting}
def get_value(self, html_path)
\end{lstlisting}
Берётся первый элемент дерева, удовлетворяющий пути $html\_path$. Для атрибутов <<href>>, <<title>>, <<src>> возвращается значение соответствующего атрибута тега. Для атрибута <<style>> возвращается значение после <<//>>. Во всех остальных случаях возвращается содержимое тега с помощью метода $text\_content$.
\\

\Section{HTMLPath}

Пути в $HTMLTree$, представляющие из себя XPath до HTML тега в дереве и название атрибута тега.
\\

\begin{lstlisting}
def split_xpath(self)
\end{lstlisting}
Разделяет путь на компоненты по одной вершине. Для каждой компоненты хранится кортеж-пара (тег, индекс тега). Нумерация индексов с 1. Если индекс отсутствует, то значение равно 0. Возвращает список кортежей.
\\

\begin{lstlisting}
def merge_xpath(self, extract_list, relative=False)
\end{lstlisting}
Склеивает относительный или абсолюный путь из списка кортежей формата, возвращаемого $split\_xpath$.
\\

\begin{lstlisting}
def get_common_prefix(self, tree_path, in_block=False)
\end{lstlisting}
Наибольший общий префикс находим следующим образом: оба пути разделяем на компоненты и двумя указателями идём пока теги совпадают. Если $in\_block$ выставлен в False, то разница индексов не учитывается, а у итогового кортежа выставляется значение 0. Для путей одного блока сравнение идёт с учётом индексов. Итоговый кортеж склеивается в путь. В качестве атрибута берётся атрибут параметра $tree\_path$.
\\

\begin{lstlisting}
def get_relative_path(self, tree_path)
\end{lstlisting}
Подразумевается, что $tree\_path$ является префиксом пути, тогда оба пути разделяются и берётся только хвост текущего пути, который склеивается в итоговый путь с флагом $relative=True$.
\\

\begin{lstlisting}
def len(self)
\end{lstlisting}
Возвращает длину списка компонент пути.
\\

\begin{lstlisting}
def drop_for_len(self, len)
\end{lstlisting}
Склеиваются лишь первые $len$ элементов списка компонент пути. Поле $attr$ выставляется в None.
\\

\begin{lstlisting}
def concat(self, tree_path)
\end{lstlisting}
Объединение строк путей с проверкой на наличие <<.>> в начале для относительного пути. Атрибут берётся из параметра $tree\_path$.
\\

\Section{JSONTree}

Дерево структуры JSON, представляет из себя обёртку над объектами Python, полученными из JSON представления. Реализация идентична реализации HTMLTree с той разницей, что вместо XPath используется JSONPath одноимённой библиотеки. А также поле $classes$ и метод $cssselect$ возвращают пустой список.
\\

\Section{JSONPath}

Пути в $JSONTree$, представляющие из себя JSONPath. Реализация аналогична реализации $HTMLPath$.
\\

\Section{Component}

Класс определяющий базовые поля компонент результата парсинга и реализующий серилизацию и сравнение объектов. К базовым полям относятся: $type$, $alignment$, $page\_url$, $title$. Серилизация реализована с помощью $jsonpickle$. А сравнение -- сравнением словарей, так как объекты <<плоские>>.
\\

\Section{ParserResult}

Класс результатов парсинга, представляющих из себя список объектов типа $Component$. Реализована серилизация с помощью $jsonpickle$.
\\

\begin{lstlisting}
def add(self, component)
\end{lstlisting}
Добавляет компоненту в список $components$.
\\

\begin{lstlisting}
def count(self, component_type=None)
\end{lstlisting}
Возвращает размер списка. Если задан $component\_type$, то возвращает количество компонент данного типа.
\\

\Section{SearchMarkup}

Тривиальная имплементация интерфейса $Markup$ с серилизацией через $jsonpickle$.
\\

\Section{SearchMarkupComponent}

Расширение класса $Component$ до базового класса всех компонент поисковой разметки.
\\

\Section{SearchMarkupSearchResult, SearchMarkupAdv,}
\Section{SearchMarkupWizardImage, SearchMarkupWizardNews}

Специализации компонент поисковой выдачи: документ, реклама, колдунщики картинок и новостей, которые задают поля типа компоненты и определяют специфические поля.
\\

\Section{Algorithm\_v2}

Реализация основного алгоритма на базе сжатого бора путей и с поддержкой различных способов разрешения коллизий.
\\

\begin{lstlisting}
types
\end{lstlisting}
Список типов компонент, которые встречаются в разметке.
\\

\begin{lstlisting}
markup_type
\end{lstlisting}
Тип разметки, согласованный с $MarkupTypeRegistry$.
\\

\begin{lstlisting}
root
\end{lstlisting}
Корень бора. Каждая вершина бора -- объект типа $Node$ -- содержит поля:
\begin{itemize}
	\item $indexes$ -- список индексов типов компонент, которые встречаются по пути, соответствующему данной вершине бора, в соответствии со списком $types$,
	\item $samples$ -- список компонент разметки по одной на каждый тип, согласно списку $indexes$,
	\item $treepaths$ -- список рёбер, выходящих из вершины. Элемент списка -- кортеж (объект $TreePath$, объект $Node$) -- путь до вершины и сама вершина.
\end{itemize}


\begin{lstlisting}
def __init__(self, directory, selector)
\end{lstlisting}
Конструктор принимает директорию с исходниками документов для обучения и объект для разрешения коллизий.
\\

\begin{lstlisting}
def learn(self, markup_list)
\end{lstlisting}
Метод построения парсера.

Предполагается получение списка разметок одного типа, поэтому тип разметки определяется по первому элементу списка.

Далее для каждой компоненты всех разметок входного списка выполняется следующая процедура: для всех полей компоненты (если поле является списком, то для каждого элемента списка) строится единый общий префикс с флагом $in\_block$. Таким образом находится путь до объединяющего узла компоненты. Параллельно с этим определяется тип компоненты и формируется список $types$. Дальше эта компонента добавляется в бор по полученному пути методом $add\_component$.

После построение бора и определения всех остальных внутренних полей вызывается обучение $selector'$а.
\\

\begin{lstlisting}
def add_component(self, node, treepath, index_of_type, sample)
\end{lstlisting}
Рекурсивная функция добавления компоненты в бор.

Принимает текущую вершину бора; суффикс пути, который ещё остался; индекс типа компоненты, согласно списку $types$; добавляемую компоненту.

Если путь пустой, то делается проверка на наличие компоненты такого типа в текущую вершину и, при необходимости, добавляется в списки $samples$ и $indexes$. И выполнение функции заканчивается.

Среди всех путей, исходящих из текущей вершины, ищется такой, чтобы общий префикс с пришедшим в параметрах был не пуст. Причём общий префикс ищется без учёта индексов узлов в дереве, тем самым в боре строятся обобщающие пути, единые для разных компонент. Если найденный путь короче пришедшего суффикса, то рекурсивно переходим в вершину бора, в которую ведёт этот путь и продолжаем процесс. Иначе делим ребро, добавляя новую вершину в бор и размещая в этой вершине нашу компоненту.

Если же ни один путь не подошёл, то в бор добавляется новая вершина с путём до неё равным текущему суффиксу.

При передачи на следующие уровни рекурсии компонента проходит через функцию $get\_relative\_component$, которая для всех полей компоненты делает пути относительными к тому, который уже получен в боре.
\\

\begin{lstlisting}
def parse(self, raw_page)
\end{lstlisting}
Головной метод парсинга строки, которые создает объект $ParserResult$ для результата работы, строит дерево из пришедшей строки и вызывает обход бора в глубину -- $dfs$.
\\

\begin{lstlisting}
def dfs(self, node, tree, parser_result, check=False, current_path=None)
\end{lstlisting}
Рекурсивный обход бора в глубину с параллельным движение по дереву.

Принимает текущую вершину бора; текущую вершину дерева; объект результата; флаг проверки; текущий путь до вершины дерева. Если высталвен флаг $check$, то метод работает в режиме проверки и пытается найти компоненту $parser\_result$ и её путь в дереве.

Первым делом пытаемся спарсить какую-либо компоненту, имеющую такой обобщённый путь, итерируясь по них в порядке, заданном $selector'$ом. Если получилось удачно, то, в зависимости от флага $check$ либо добавляем компоненту к результату, либо после проверки на равенство сообщаем успешный результат поиска и возвращаем вершину дерева, путь и индекс типа компоненты.

А дальше перебираем все обобщённые пути бора и реальные пути дерева, соответствующие путям бора, и рекурсивно переходим в следующие вершины.
\\

\begin{lstlisting}
def parse_component(self, element, sample)
\end{lstlisting}
Данный метод пытается, начиная с вершины дерева $element$, спарсить компоненту $sample$, перебирая все поля. Поддерживаются поля трёх типов: строка (просто копируется), объект $TreePath$ (выполняется $get\_value$ для него), список объектов $TreePath$ (из них строится обобщающий путь, а потом парсятся все элементы, которые удовлетворяют этому пути).
\\

\begin{lstlisting}
def get_substitution(self, tree, markup)
\end{lstlisting}
Метод, выполняющий подстановку значений вместо путей в разметке. Для всех полей каждой компоненты разметки выполняется $get\_value$ (если тип поля строка, то она просто копируется).

Метод требуется для $BlackListSelector$.
\\

\begin{lstlisting}
def get_element_for_parser_component(self, parser_component, tree)
\end{lstlisting}
Вспомогательный метод для $BlackListSelector$, который запускает $dfs$ с правильными параметрами для нахождения заданной компоненты в дереве.
\\

\Section{SimpleSelector}

Тривиальная имплементация интерфейса $Selector$, которая разрешает коллизии в порядке уменьшения количества полей у компонент.
\\

\begin{lstlisting}
def get_iter(self, **kwargs)
\end{lstlisting}
Метод ожидает словарь с элементом <<node>> -- вершиной бора. Строится список из индексов на индексы типов компонент, соответствующих полученной вершине бора. Затем этот список сортируется в порядке уменьшения размера словаря компонент. Получившийся список возвращается в качестве итератора.
\\

\Section{BlackListSelector}

Имплементация интерфейса $Selector$ с построение чёрных списков элементов поддерева и их CSS селекторов для типов компонент, позволяющих различить компоненты разного типа.
\\

\begin{lstlisting}
def get_iter(self, **kwargs)
\end{lstlisting}
Метод ожидает словарь с элементом <<node>> -- вершиной бора и <<tree>> -- деревом входной строки. Как и в $SimpleSelector$ строится список из индексов на индексы типов компонент, соответствующих полученной вершине бора и не имеющих в чёрных списках элементов дерева $tree$. Затем этот список сортируется в порядке уменьшения размера словаря компонент. Получившийся список возвращается в качестве итератора.
\\

\begin{lstlisting}
def is_not_black(self, element, element_type)
\end{lstlisting}
Для каждого CSS селектора из чёрного списка компоненты типа $element\_type$ ищутся соответствующие им вершины в дереве $element$. Если находится хотя бы один, то эта компонента из чёрного списка и не должна парситься в этом дереве. Иначе возвращается $True$.
\\

\begin{lstlisting}
def learn(self, algorithm, markup_list)
\end{lstlisting}
Для каждой разметки из входного списка строится два результата -- обученным алгоритмом и подстановкой значений из дерева в разметку. Если результаты различаются, то находятся лишние (либо неверно определённый тип) компоненты, которые были распознаны алгоритмом, и их пути в дереве. Для каждой такой компоненты вызывается метод $add\_black\_for\_element$.
\\

\begin{lstlisting}
def add_black_for_element(self, algorithm, element, element_path, index_of_element_type, markup_list)
\end{lstlisting}
В первую очередь составляется список кортежей (тег, класс) всех элементов поддерева.

Затем для каждой разметки из входного списка находятся компоненты того типа, который хотим отличить. Обрезанием полного пути до заголовка компоненты, находим путь до объединяющего элемента компоненты. По этому в дереве получаем вершину и проверяем, какие кортежи (тег, класс) имеются в поддереве этой вершины. Для всех найденных в списке $list\_flag$ отмечаем, что эта пара не походит.

В заключении, находим первую кортеж-пару, которая не была исключена и ещё не добавлена в чёрный список искомого типа компоненты, и добавляем её в $blacks$.
\\


